<% if (getPackageName(currentModelElement) != "") { %>
package ${getPackageName(currentModelElement)};
<% } %>

/**
 * Autogenerated class ${currentModelElement.name}
 */
public class ${currentModelElement.name} {
       
<%
		def belongsToMap = [:]
		def hasManyMap = [:]
		def embeddedList =[]
		def attributeConstrainsMap=[:]
        getAttributes(currentModelElement).each { attribute ->
                def attributeName = attribute.name
                def attributeType = javaType(attribute.type)
                
%>	${attributeType} ${attributeName}
<%
        	attributeConstrainsMap.put("${attributeName}",taggedValueMap(attribute))
        }
        getAssociationEnds(model, currentModelElement).each { sourceEnd ->
                def association = sourceEnd.association
                def targetEnd = association.connection.find { end -> end != sourceEnd }
				def targetType = getEndType(targetEnd)
				def targetName = getEndName(targetEnd)
				def	className = "${targetEnd.participant.name}"//"${firstCharUpper(targetName)[0..-2]}"
                if (!sourceEnd.isNavigable()&&targetEnd.isNavigable()) {
						if(isOneToOne(sourceEnd, targetEnd)){
%>	${firstCharUpper(targetName)} ${targetName}
<%
							attributeConstrainsMap.put("${targetName}",taggedValueMap(targetEnd))
						} else if(isManyToMany(sourceEnd, targetEnd)){
							hasManyMap.put(targetName,className)
							attributeConstrainsMap.put("${targetName}",taggedValueMap(targetEnd))
						} else if(isOneToMany(sourceEnd, targetEnd)){
							belongsToMap.put("${firstCharLower(targetName)}",className)
						}
        				
                } else if (sourceEnd.isNavigable() && !targetEnd.isNavigable()){
						if(isOneToOne(sourceEnd, targetEnd)){
							belongsToMap.put("${firstCharLower(targetName)}",className)
						} else if(isManyToMany(sourceEnd, targetEnd)){
							belongsToMap.put("${firstCharLower(className)}",className)
							hasManyMap.put(targetName,className)
							attributeConstrainsMap.put("${targetName}",taggedValueMap(targetEnd))
						} else if(isOneToMany(sourceEnd, targetEnd)){
							hasManyMap.put(targetName,className)
							attributeConstrainsMap.put("${targetName}",taggedValueMap(targetEnd))
						}
				} else if (sourceEnd.isNavigable()&&targetEnd.isNavigable()) {
				
					if(isComposite(sourceEnd)) {
						embeddedList.add(targetName as String)
					}
					
					if(isOneToOne(sourceEnd, targetEnd) && !isComposite(targetEnd)){
%>	${firstCharUpper(targetName)} ${targetName}
<%
						attributeConstrainsMap.put("${targetName}",taggedValueMap(targetEnd))	
						
					} else if( isOneToMany(sourceEnd, targetEnd) && !isComposite(targetEnd)){
						hasManyMap.put(targetName,className) 
        				attributeConstrainsMap.put("${targetName}",taggedValueMap(targetEnd))
        				
					} else if(isOneToOne(sourceEnd, targetEnd) && !isComposite(targetEnd)){
						attributeConstrainsMap.put("${targetName}",taggedValueMap(targetEnd))
						
%>	${firstCharUpper(targetName)} ${targetName}
<%
					} else if(isManyToMany(sourceEnd, targetEnd) && !isComposite(targetEnd)){
								hasManyMap.put(targetName,className)
								attributeConstrainsMap.put("${targetName}",taggedValueMap(targetEnd))
							
					} else if(isManyToOne(sourceEnd, targetEnd) && !isComposite(targetEnd)){
						attributeConstrainsMap.put("${targetName}",taggedValueMap(targetEnd))
%>	${firstCharUpper(targetName)} ${targetName}
<%		
					}
				}
		}
	if(belongsToMap.size()>0){
%>	
	static belongsTo = ${belongsToMap}
<%
	} 
	if(hasManyMap.size()>0){	
%>	
	static hasMany = ${hasManyMap}
<%
	}
	if(embeddedList.size()>0) {
%>	
	static embedded = ${embeddedList}
<%
	}
	if(attributeConstrainsMap.size()>0) {
%>	
	static constraints = { 
<%
		attributeConstrainsMap.each{key, value ->
		  def valueBuffer = new StringBuffer()
			value.each { keyContrain, valueContrain ->
					if (valueBuffer.length() > 0) {
			        	valueBuffer.append(",")
			        }
			         valueBuffer.append(keyContrain+":"+valueContrain)
			}
%>		${key}(${valueBuffer.toString()})
<%	
		} 
%>	}
<%
	}
%>
}