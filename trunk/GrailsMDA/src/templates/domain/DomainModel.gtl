<%= getPackageName(currentModelElement) ? "package ${getPackageName(currentModelElement)}" : "" %>
 
/**
 * Autogenerated class ${currentModelElement.name}
 */

public class ${currentModelElement.name} {
       
<%
		final String MAPPED_BY = "mappedBy"
		final String FETCH_MODE = "fetchMode"
		final String MAPPING = "mapping"
		final String CONSTRAINTS = "constraints"
		final String TRANSIENTS = "transients"
		final String NAMED_QUERIES = "namedQueries"
		def belongsToMap = [:]
		def hasManyMap = [:]
		def embeddedList = []
		def namedQueries = [:]
		def attributeConstrainsMap=[:]
		def mappedByList = taggedValueMap(MAPPED_BY, currentModelElement)
		def fetchModeList = taggedValueMap(FETCH_MODE, currentModelElement)
		def transientsList = taggedValueMap(TRANSIENTS, currentModelElement)
		def namedQueriesList = taggedValueMap(NAMED_QUERIES, currentModelElement)
		def mappingList = ["${currentModelElement.name}":taggedValueMap(MAPPING, currentModelElement).values()]
        getAttributes(currentModelElement).each { attribute ->
                def attributeName = attribute?.name
                def attributeType = javaType(attribute.type)
                
%>	${attributeType} ${attributeName}
<%
        	attributeConstrainsMap.put("${attributeName}",taggedValueMap(CONSTRAINTS,attribute))
			mappingList.put("${attributeName}",taggedValueMap(MAPPING, attribute).values())
        }
        getAssociationEnds(model, currentModelElement).each { sourceEnd ->
                def association = sourceEnd.association
                def targetEnd = association.connection.find { end -> end != sourceEnd }
				def targetType = getEndType(targetEnd)
				def targetName = "${getEndName(targetEnd)}"
				def	className = "${targetEnd.participant?.name}"//"${firstCharUpper(targetName)[0..-2]}"
                if (!sourceEnd.isNavigable()&&targetEnd.isNavigable()) {
						if(isOneToOne(sourceEnd, targetEnd)){
%>	${firstCharUpper(targetName)} ${targetName}
<%
							attributeConstrainsMap.put("${targetName}",taggedValueMap(CONSTRAINTS,targetEnd))
							mappingList.put("${targetName}",taggedValueMap(MAPPING, targetEnd).values())
						} else if(isManyToMany(sourceEnd, targetEnd)){
							hasManyMap.put(targetName,className)
							attributeConstrainsMap.put("${targetName}",taggedValueMap(CONSTRAINTS,targetEnd))
							mappingList.put("${targetName}",taggedValueMap(MAPPING, targetEnd).values())
						} else if(isOneToMany(sourceEnd, targetEnd)){
							belongsToMap.put("${firstCharLower(targetName)}",className)
						}
        				
                } else if (sourceEnd.isNavigable() && !targetEnd.isNavigable()){
						if(isOneToOne(sourceEnd, targetEnd)){
							belongsToMap.put("${firstCharLower(targetName)}",className)
						} else if(isManyToMany(sourceEnd, targetEnd)){
							belongsToMap.put("${firstCharLower(className)}",className)
							hasManyMap.put(targetName,className)
							attributeConstrainsMap.put("${targetName}",taggedValueMap(CONSTRAINTS,targetEnd))
							mappingList.put("${targetName}",taggedValueMap(MAPPING, targetEnd).values())
						} else if(isOneToMany(sourceEnd, targetEnd)){
							hasManyMap.put(targetName,className)
							attributeConstrainsMap.put("${targetName}",taggedValueMap(CONSTRAINTS,targetEnd))
							mappingList.put("${targetName}",taggedValueMap(MAPPING, targetEnd).values())
						}
				} else if (sourceEnd.isNavigable()&&targetEnd.isNavigable()) {
				
					if(isComposite(sourceEnd)) {
						embeddedList.add(targetName as String)
					}
					
					if(isOneToOne(sourceEnd, targetEnd) && !isComposite(targetEnd)){
%>	${firstCharUpper(className)} ${targetName}
<%
						attributeConstrainsMap.put("${targetName}",taggedValueMap(CONSTRAINTS,targetEnd))	
						mappingList.put("${targetName}",taggedValueMap(MAPPING, targetEnd).values())
					} else if( isOneToMany(sourceEnd, targetEnd) && !isComposite(targetEnd)){
						hasManyMap.put(targetName,className) 
        				attributeConstrainsMap.put("${targetName}",taggedValueMap(CONSTRAINTS,targetEnd))
        				mappingList.put("${targetName}",taggedValueMap(MAPPING, targetEnd).values())
					} else if(isOneToOne(sourceEnd, targetEnd) && !isComposite(targetEnd)){
						attributeConstrainsMap.put("${targetName}",taggedValueMap(CONSTRAINTS,targetEnd))
						mappingList.put("${targetName}",taggedValueMap(MAPPING, targetEnd).values())
%>	${firstCharUpper(className)} ${targetName}
<%
					} else if(isManyToMany(sourceEnd, targetEnd) && !isComposite(targetEnd)){
						hasManyMap.put(targetName,className)
						attributeConstrainsMap.put("${targetName}",taggedValueMap(CONSTRAINTS,targetEnd))
						mappingList.put("${targetName}",taggedValueMap(MAPPING, targetEnd).values())
					} else if(isManyToOne(sourceEnd, targetEnd) && !isComposite(targetEnd)){
						attributeConstrainsMap.put("${targetName}",taggedValueMap(CONSTRAINTS,targetEnd))
						mappingList.put("${targetName}",taggedValueMap(MAPPING, targetEnd).values())
%>	${firstCharUpper(className)} ${targetName}
<%		
					}
				}
		}
	if(belongsToMap.size()>0){
%>	
	static belongsTo = ${belongsToMap}
<%
	} 
	if(hasManyMap.size()>0){	
%>	
	static hasMany = ${hasManyMap}
<%
	}
	if(mappedByList.size()>0){	
		 mappedByList.each{key, value ->
%>	
	static mappedBy = [${value}]
<%
		 }
	}
	if(fetchModeList.size()>0){	
		fetchModeList.each{key, value ->
%>	
	static fetchMode = [${value}]
<%
		}
	}
	if(namedQueriesList.size()>0){	
		namedQueriesList.each{key, value ->
%>	
	static namedQueries = {${value}}
<%
		}
	}
	if(transientsList.size()>0){	
		transientsList.each{key, value ->
%>	
	static transients = [${value}]
<%
		}
	}
	if(embeddedList.size()>0) {
%>	
	static embedded = ${embeddedList}
<%
	}
	mappingList.putAll(['tablePerHierarchy':['true']])
	if(mappingList.size()>0) {
		def valueBuffer = new StringBuffer()
		mappingList.each{ key, value ->
			if(value.size()>0){
				if(key!=currentModelElement?.name){
					value.each{valueText->
						valueBuffer.append("${key} ${valueText}")
						valueBuffer.append("\n\t\t")
					}
				} else {
					value.each{valueText->
						valueBuffer.append("${valueText}")
						valueBuffer.append("\n\t\t")
					}
				}
			}  
		}
		if(valueBuffer.length()>3){
			valueBuffer.delete(valueBuffer.length()-3,valueBuffer.length())

		def comment = "//tablePerHierarchy has to be true, since impl class should also work on the same table"
%>	
	$comment 
	static mapping = { 
		${valueBuffer.toString()}
	}
<%
		}
	}
	if(attributeConstrainsMap.size()>0) {
%>	
	static constraints = { 
<%
		attributeConstrainsMap.each{key, value ->
			def valueBuffer = new StringBuffer()
			value.each { keyContrain, valueContrain ->
				if (valueBuffer.length() > 0) {
					valueBuffer.append(",")
				}
				valueBuffer.append(valueContrain)
			}
%>		${key}(${valueBuffer.toString()})
<%	
		} 
%>	}
<%
	}
%>
}